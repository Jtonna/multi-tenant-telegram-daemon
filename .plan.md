# Implementation Plan — multi-tenant-telegram-daemon-4gz

**Ticket**: multi-tenant-telegram-daemon-4gz — Telegram bot access control: DM allowlist + group allowlist

## Overview

Add default-deny access control to the Telegram plugin so that only explicitly allowlisted user IDs (for DMs) and group IDs (for group chats) are processed. A new `/config` command (always accessible) lets any user discover their Telegram ID and group chat ID for allowlist configuration.

## Sub-tasks

### 1. Add allowlist config parsing in index.ts + update createBot signature

- **Complexity**: light
- **Files touched**: `telegram-integration/src/index.ts`, `telegram-integration/src/bot.ts`
- What to do:
  - Define a `BotAccessConfig` interface (or similar) in `bot.ts` with two fields: `allowedUserIds: Set<number>` and `allowedGroupIds: Set<number>`
  - In `index.ts`, read `TELEGRAM_ALLOWED_USER_IDS` and `TELEGRAM_ALLOWED_GROUP_IDS` from `process.env`
  - Parse each as a comma-separated string of numeric IDs; trim whitespace; filter out empty/NaN values
  - Empty or missing env var produces an empty Set (default-deny)
  - Log the count of allowed user IDs and group IDs at startup for visibility
  - Pass the parsed config as a new parameter to `createBot(token, chatRouter?, accessConfig?)`

### 2. Add /config command in bot.ts

- **Complexity**: light
- **Files touched**: `telegram-integration/src/bot.ts`
- What to do:
  - Register `bot.command("config", ...)` **before** the allowlist guard (so it always fires)
  - Reply with a formatted message containing:
    - `Your Telegram user ID: <id>` (from `ctx.from.id`)
    - If `ctx.chat.type` is `group` or `supergroup`: `Group chat ID: <id>` and `Chat type: <type>`
    - A hint: "Give these IDs to the bot admin to get allowlisted."
  - Place it alongside the existing `/start` command registration

### 3. Add allowlist middleware/guard in bot.ts

- **Complexity**: standard
- **Files touched**: `telegram-integration/src/bot.ts`
- What to do:
  - After the `/start` and `/config` command registrations, add a middleware function that runs before the `bot.on("message")` handler
  - The middleware checks the access config; if no config is provided (undefined), allow all traffic (backwards-compatible for tests)
  - For DMs (`chat.type === "private"`): check `ctx.from.id` against `allowedUserIds`. If not present, silently drop (return without calling `next()`)
  - For groups/supergroups (`chat.type === "group" | "supergroup"`): check `ctx.chat.id` against `allowedGroupIds`. If not present, silently drop
  - For channels: silently drop (not supported)
  - Log denied attempts at debug level (one line, includes user ID and chat ID) so admins can troubleshoot
  - Important ordering: grammY processes command handlers registered via `bot.command()` before generic `bot.on("message")` middleware, but the guard should be a `bot.use()` middleware placed **after** command registrations and **before** the `bot.on("message")` handler. Verify that grammY's handler ordering means `/start` and `/config` fire before the guard. If not, add explicit command checks inside the guard to bypass allowlist for those commands.

### 4. Update .env.example with new vars and comments

- **Complexity**: light
- **Files touched**: `telegram-integration/.env.example`
- What to do:
  - Add `TELEGRAM_ALLOWED_USER_IDS=` with a comment explaining comma-separated Telegram user IDs
  - Add `TELEGRAM_ALLOWED_GROUP_IDS=` with a comment explaining comma-separated Telegram group chat IDs
  - Add a comment: "Use the /config command in Telegram to discover your user ID and group chat ID"
  - Add a comment: "Empty values = deny all (default-deny). Bot is locked down unless IDs are listed."

### 5. Add tests for allowlist behavior and /config command

- **Complexity**: standard
- **Files touched**: `telegram-integration/src/__tests__/bot.test.ts`
- What to do:
  - Reuse the `mockContext()` pattern from `chatRouterClient.test.ts` — create a similar helper in `bot.test.ts` that builds a mock `Context` with `reply`, `from`, `chat`, and `message` fields
  - **Allowlist guard tests** (test the guard function directly or via bot middleware):
    - DM from allowed user ID -> message is processed (forwarded/echoed)
    - DM from non-allowed user ID -> message is silently dropped
    - Message in allowed group -> processed
    - Message in non-allowed group -> dropped
    - Empty allowlists -> all messages denied
    - No access config (undefined) -> all messages allowed (backwards compat)
  - **/config command tests**:
    - In a DM: reply includes the user's Telegram ID, does NOT include group info
    - In a group: reply includes both user ID and group chat ID + type
  - **/start command test**: verify it works even when user is not allowlisted
  - Consider extracting the guard logic into a standalone function (`checkAccess(chatType, userId, chatId, config) => boolean`) to make it independently testable without needing to mock grammY middleware chains

## Testing strategy

- **Unit tests** (in `bot.test.ts`):
  - Extract `checkAccess` as a pure function and test all combinations: private/allowed, private/denied, group/allowed, group/denied, supergroup/allowed, supergroup/denied, channel/denied, no-config/allow-all, empty-sets/deny-all
  - Test `/config` command reply content for DM vs group contexts
  - Test that existing `createBot` tests still pass (no access config = backwards compatible)
- **Manual smoke test**:
  - Start bot with empty allowlists -> confirm all messages are silently ignored
  - Use `/config` to get IDs -> add to `.env` -> restart -> confirm messages work
  - Test in both DM and group contexts
