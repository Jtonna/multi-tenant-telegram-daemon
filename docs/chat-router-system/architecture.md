# Chat Router System: Architecture

## Layered Design

The chat router is organized into four layers, each with a single responsibility:

1. **Types** -- Defines all data structures and the service interface contract. Every other layer depends on types but types depend on nothing.
2. **Store** -- Persistence layer that reads and writes timeline entries and conversations. Currently backed by a JSON file; designed to be swappable for SQLite without changing any other layer.
3. **Service** -- All business logic. Validates inputs, orchestrates store operations, and provides the methods that transport adapters call. This is the source of truth for the system's behavior.
4. **REST API** -- A thin Express-based HTTP adapter that translates HTTP requests into service method calls. Contains no business logic of its own. The `createServer()` factory returns an Express app without calling `.listen()`, keeping the server testable with supertest. The entry point in `index.ts` is responsible for calling `.listen()`.

Each layer only depends on the one below it. The REST API calls the service, the service calls the store, and the store manages its own internal state.

## The Service Layer Pattern

The core architectural principle is that all business logic lives in the service layer. The REST API (and future CLI and WebSocket adapters) are thin wrappers that:

- Parse incoming requests into the shapes the service expects.
- Call the appropriate service method.
- Format the response for their transport protocol.

This means adding a new transport adapter requires zero changes to the service or store. The adapter just maps its protocol to the same service interface.

The service interface (IChatRouterService) defines seven methods: ingestMessage, recordResponse, getTimeline, getUnifiedTimeline, listConversations, getConversation, and healthCheck. All adapters call exactly these methods.

## Data Flow

When a message arrives via the REST API:

1. The Express router receives the HTTP POST request and parses the JSON body.
2. The router calls service.ingestMessage() with the parsed InboundMessage.
3. The service validates all required fields (platform, message ID, chat ID, sender name, sender ID, timestamp). If any are missing, it throws an error which the router translates to HTTP 400.
4. The service maps the inbound message to a TimelineEntry (adding direction "in", converting the platformMeta object to a JSON string via JSON.stringify, and assigning nullable fields).
5. The service calls store.ingestTransaction(), which sequentially inserts the timeline entry and upserts the conversation record (creating it on first message, or incrementing messageCount, updating lastMessageAt, overwriting the label, and conditionally updating platformChatType on subsequent messages). Each step triggers a separate persist to disk.
6. The store assigns an auto-increment ID and createdAt timestamp, then returns the completed TimelineEntry.
7. The service returns the TimelineEntry to the router, which sends it as HTTP 201 JSON.

Outbound responses follow a similar path through recordResponse, with direction set to "out" and a synthetic platform message ID generated by the service.

## The Normalized Message Model

All messages are normalized to a common format regardless of which platform they came from.

**InboundMessage** is what plugins send to the chat router. It contains the platform identifier, platform-specific message and chat IDs (as strings to accommodate different platforms), sender information, message text, a millisecond timestamp, and an optional platformMeta bag for preserving platform-specific data.

**TimelineEntry** is the persisted form. It adds an auto-increment ID, a direction field ("in" or "out"), and a createdAt timestamp. The platformMeta is serialized to a JSON string. This is what all query methods return.

**OutboundMessage** represents a response that should be delivered back to a platform. It contains the timeline entry ID, target platform and chat ID, response text, and an optional reference to the message being replied to.

**Conversation** tracks unique platform-plus-chat-ID pairs. It is created automatically when the first message from a new chat arrives. It stores a display label, a platformChatType (e.g., "private", "group"), first-seen and last-message timestamps, and a running message count. Conversations are never explicitly created or deleted by API callers.

## Platform Abstraction

The system currently defines three platform types: telegram, discord, and web. All platform-specific data is carried in two places:

- The **platformChatType** field captures platform-specific chat classifications (e.g., Telegram's "private", "group", "supergroup").
- The **platformMeta** field is a freeform JSON bag where plugins can stash any platform-specific data they want preserved (e.g., Telegram's full User object, Discord guild information).

The chat router never interprets platformMeta. It stores and returns it as-is. This means new platform-specific fields can be added without any changes to the chat router.

## Persistence

The current store is a JSON file that holds all timeline entries and conversations in memory, flushing to disk after each mutation. It supports an in-memory mode (used in tests) where no file I/O occurs.

The store maintains its own auto-increment counters for timeline entry IDs and conversation IDs (both starting at 1). The ingest operation (insert timeline entry plus upsert conversation) is performed as two sequential steps, each persisting to disk separately. It is not truly atomic -- a crash between the two writes could leave state inconsistent.

The store interface is designed so that a future SQLite implementation would expose the same methods with the same signatures. The service layer would require no changes for this swap.

## Configuration

The chat router is configured entirely through environment variables:

- **CHAT_ROUTER_PORT** controls the HTTP port (default 3100).
- **CHAT_ROUTER_DATA_DIR** controls where the persistence file is written (default ./data). The data file is named chat-router.json within this directory.

The server performs graceful shutdown on SIGINT and SIGTERM, closing the HTTP server and flushing the store to disk.
